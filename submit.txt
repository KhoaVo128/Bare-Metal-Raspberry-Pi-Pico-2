
############################################################
./readme.txt

############################################################
All requirements are met and the program is fully functional.

############################################################
./drivers/keypad.h

############################################################
/*
KHOA THANH VO

KEYPAD HEADER FILES

DECLARATIONS OF FUNCTIONS

*/

#ifndef KEYPAD_H
#define KEYPAD_H

void configure_keypad();
void task_keypad_scan();
int keypad_getchar(char *c);

#endif

############################################################
./drivers/keypad.c

############################################################
/*
KHOA THANH VO

DEFINES FUNCTIONS IN KEYPAD HEADER FILE
DEFINE MACROS, FILE SCOPE VARIABLE(S), ANDHELPER FUNCTIONS

*/

#include <rp2350/resets.h>
#include <rp2350/sio.h>
#include <rp2350/io_bank0.h>
#include <rp2350/pads_bank0.h>
#include "keypad.h"
#include "interrupt.h"

#define ROW0 6
#define ROW1 7
#define ROW2 8
#define ROW3 9

#define COL0 10
#define COL1 11
#define COL2 12

#define NO_KEY 0

#define ALL 15

#define GPIO_RESETS (RESETS_RESET_IO_BANK0_MASK | RESETS_RESET_PADS_BANK0_MASK)

static char keypad_char;

static void keypad_scan_row(int8_t row){
	SIO_GPIO_OUT_CLR	= (1<<ROW0) |(1<<ROW1) |(1<<ROW2) |(1<<ROW3);
	SIO_GPIO_OE_CLR		= (1<<ROW0) |(1<<ROW1) |(1<<ROW2) |(1<<ROW3);
	switch (row)
	{
	case -1:
		break;
	case 0:
		SIO_GPIO_OE_SET = (1<<ROW0);
		break;
	case 1:
		SIO_GPIO_OE_SET = (1<<ROW1);
		break;
	case 2:
		SIO_GPIO_OE_SET = (1<<ROW2);
		break;
	case 3:
		SIO_GPIO_OE_SET = (1<<ROW3);
		break;
	default:
		SIO_GPIO_OE_SET	= (1<<ROW0) |(1<<ROW1) |(1<<ROW2) |(1<<ROW3);
		break;
	}
}

static uint8_t read_col(){
	uint8_t retval = NO_KEY;
	if(0==(SIO_GPIO_IN & (1<<COL0))){
		retval = 1;
	}
	else if(0==(SIO_GPIO_IN & (1<<COL1))){
		retval = 2;
	}
	else if(0==(SIO_GPIO_IN & (1<<COL2))){
		retval = 3;
	}
	return retval;
} 

void configure_keypad(){	
	resets.reset_clr = GPIO_RESETS;
    while(!(resets.reset_done & GPIO_RESETS))
	    continue;
	const uint32_t COMMON_PADS_BANK0_GPIO_COL = 
	PADS_BANK0_GPIO27_OD(1) 
	| PADS_BANK0_GPIO27_IE(1) 
	| PADS_BANK0_GPIO27_DRIVE(0) 
	| PADS_BANK0_GPIO27_PUE(1) 
	| PADS_BANK0_GPIO27_PDE(0) 
	| PADS_BANK0_GPIO27_SCHMITT(0) 
	| PADS_BANK0_GPIO27_SLEWFAST(0);

	const uint32_t COMMON_PADS_BANK0_GPIO_ROW = 
	PADS_BANK0_GPIO27_OD(0) 
	| PADS_BANK0_GPIO27_IE(0) 
	| PADS_BANK0_GPIO27_DRIVE(0) 
	| PADS_BANK0_GPIO27_PUE(0) 
	| PADS_BANK0_GPIO27_PDE(0) 
	| PADS_BANK0_GPIO27_SCHMITT(0) 
	| PADS_BANK0_GPIO27_SLEWFAST(0);

	const uint32_t COMMON_BANK0_GPIO_CTRL = 
	IO_BANK0_GPIO27_CTRL_IRQOVER(0) |
	IO_BANK0_GPIO27_CTRL_INOVER(0)  |
	IO_BANK0_GPIO27_CTRL_OEOVER(0)  |
	IO_BANK0_GPIO27_CTRL_OUTOVER(0) |
	IO_BANK0_GPIO27_CTRL_FUNCSEL(5);


	pads_bank0.gpio10		= COMMON_PADS_BANK0_GPIO_COL;
	io_bank0.gpio10_ctrl	= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio11		= COMMON_PADS_BANK0_GPIO_COL;
	io_bank0.gpio11_ctrl	= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio12		= COMMON_PADS_BANK0_GPIO_COL;
	io_bank0.gpio12_ctrl	= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio6		= COMMON_PADS_BANK0_GPIO_ROW;
	io_bank0.gpio6_ctrl		= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio7		= COMMON_PADS_BANK0_GPIO_ROW;
	io_bank0.gpio7_ctrl		= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio8		= COMMON_PADS_BANK0_GPIO_ROW;
	io_bank0.gpio8_ctrl		= COMMON_BANK0_GPIO_CTRL;

	pads_bank0.gpio9		= COMMON_PADS_BANK0_GPIO_ROW;
	io_bank0.gpio9_ctrl		= COMMON_BANK0_GPIO_CTRL;

	keypad_scan_row(ALL);
}


void task_keypad_scan(){
	static enum {WAIT_PRESS,SCAN0, SCAN1, SCAN2, SCAN3, WAIT_RELEASE} keypad_state = WAIT_PRESS;
	static uint8_t debounce_counter = 0;
	debounce_counter++;
	if(debounce_counter == 5){
		switch (keypad_state){
			case WAIT_PRESS:
				if(read_col()!=NO_KEY){
					keypad_char = 0;
					keypad_scan_row(0);
					keypad_state = SCAN0;
				}
				break;
			case SCAN0:
				if(read_col()==NO_KEY){
					keypad_scan_row(1);
					keypad_state = SCAN1;
				}else{
					keypad_scan_row(ALL);
					keypad_char = 0 + read_col();
					keypad_state = WAIT_RELEASE;
				}
				break;
			case SCAN1:
				if(read_col()==NO_KEY){
					keypad_scan_row(2);
					keypad_state = SCAN2;
				}else{
					keypad_scan_row(ALL);
					keypad_char = 3 + read_col();
					keypad_state = WAIT_RELEASE;
				}
				break;
			case SCAN2:
				if(read_col()==NO_KEY){
					keypad_scan_row(3);
					keypad_state = SCAN3;
				}else{
					keypad_scan_row(ALL);
					keypad_char = 6 + read_col();
					keypad_state = WAIT_RELEASE;
				}
				break;
			case SCAN3:
				if(read_col()==NO_KEY){
					keypad_scan_row(ALL);
					keypad_state = WAIT_RELEASE;
				}else{
					keypad_scan_row(ALL);
					keypad_char = 9 + read_col();
					keypad_state = WAIT_RELEASE;
				}
				break;
			case WAIT_RELEASE:
				if(read_col()==NO_KEY){
					keypad_scan_row(ALL);
					keypad_state = WAIT_PRESS;
				}
				break;
			default:
				break;
		}

		debounce_counter = 0;
	}
	

}
int keypad_getchar(char *c){
	_Bool retval=1;
	uint32_t irq_status;
	__get_primask(&irq_status);
	__disable_irq();
	if(keypad_char == 0){
		retval=0;
	}else{
		char temp = keypad_char + '0';
		if(temp >= '1' && temp <= '9'){
			*c = temp;
		}else{
			if(temp == ':'){
				*c = '*';
			}
			else if(temp == ';'){
				*c = '0';
			}
			else if(temp == '<'){
				*c = '#';
			}
		}
		
		keypad_char = 0;
	}
	__set_primask(&irq_status);
	return retval;
}


############################################################
./src/test_keypad.c

############################################################
/*
KHOA THANH VO

KEYPAD TESTING MAIN PROGRAM
*/
#include "usbcdc.h"
#include "systick.h"
#include "keypad.h"
#include "led.h"

static char c;

void callback_0();


int main ( void )
{   
	configure_usbcdc();
	configure_systick();
    configure_keypad();
    configure_led();
    systick_register_callback(callback_0);
    
	while(1){
		if(!system_tick())
			continue;
	}
    return(0);
}

void callback_0(){
    task_keypad_scan();
    if(keypad_getchar(&c)){
        usbcdc_putchar(c);
    }
}